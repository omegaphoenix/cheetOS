			+-----------------------+
			|         CS 124        |
			| PROJECT 2: BOOTLOADER |
			|    DESIGN DOCUMENT    |
			+-----------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Justin Leong <jleong@caltech.edu>
John Li <jzli@caltech.edu>
Christina Lin <cylin@caltech.edu>

>> Specify how many late tokens you are using on this assignment: 0 

>> What is the Git repository and commit hash for your submission?
   (You only need to include the commit-hash in the file you submit
   on Moodle.)

   Repository URL: https://github.com/omegaphoenix/cheetOS
   commit ...

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

Printing to screen:
http://wiki.osdev.org/Printing_to_Screen

Interrupt Descriptor Table:
http://wiki.osdev.org/Interrupt_Descriptor_Table



			     PC BOOTER
			     =========

---- LOGISTICS ----

These questions will help us to keep track of the difficulty level of
assignments, as well as keeping track of which team members worked on
which parts.

>> L1: How many hours did each team member spend on this assignment?
   Make sure that each member's total time is listed.

   Justin Leong:
   John Li:
   Christina Lin: 

>> L2: What did each team member focus on for this assignment?  Keep
   descriptions to 25-30 words or less.

   Justin Leong:

   John Li:

   Christina Lin: Initial implementation of video/display API; handling of 
   general interrupts; timer interrupts.

Note that this design document is a bit long.  Most of the questions can be
answered pretty briefly.  Don't feel a need to write a long answer if it is
not required by the question.

			     GAME / DEMO
			     ===========

---- ALGORITHMS ----

>> A1: In a few sentences, describe what kind of game or demo program your
>> PC booter implements.

We built a mini Space Invaders game. The user, controlling a shooter at the
bottom of the screen, battles a fleet of alien invaders positioned at the top
of the screen. 

>> A2: In a few sentences, how does the user interact with the program?
>> What are the controls?  What should the user try to do?

The user moves the shooter right/left with arrow keys and fires bullets with
the spacebar. The shooter's bullets destroy alien spaceships upon impact, and
likewise, the aliens' bullets destroy the user's shooter. The user's goal is to
destroy the aliens before getting destroyed.

---- DATA STRUCTURES ----

>> A3: Describe any global state that your program manages in order to
>> perform its operations.  Don't focus on state managed within interrupt
>> handlers; we will look at that later.  Rather, focus on state that is
>> part of the game implementation itself.

The program maintains a global 'game' variable. 'game' is an instance of the 
Game struct, and it holds data on the x- and y- dimensions of the game board,
the player, an array of aliens, an array of bullets, the total number of 
bullets, and current level of difficulty.

The player and aliens are all instances of the Shooter struct. They store the
states of the shooters on the game board, including position, shooter type
(player or alien), portrait (how the shooter is represented on the screen),
speed, health, shooting frequency, and visibility (whether shooter is alive).

Additionally, each bullet stores its own position, direction, speed, source,
and visibility.


---- SYNCHRONIZATION ----

>> A4: From the perspective of the entire program, briefly describe how
>> the various interrupts are handled and processed within your program.
>> For example, when a timer interrupt occurs, what is the general sequence
>> of operations or updates that is performed within your program?
>> Similarly, when a keyboard interrupt occurs, what does your program do
>> in response?

>> A5: Would you say your program relies on polling or busy-waiting anywhere
>> to accomplish its tasks?  If so, what tasks?

---- RATIONALE ----

>> A6: Why did you choose the project you did?

>> A7: Did your choice of project affect any of the specific implementation
>> details of the various subsystems that you needed to use?  (For example,
>> if you implemented a scrolling game, did you implement specialized high-
>> performance video code to scroll the screen?)

>> A8: Did you run into any technical or resource limitations in the
>> implementation of your program?  (For example, bootloader didn't fit,
>> or a really useful standard library wasn't available, or you couldn't
>> achieve the desired performance level, etc.)  If so, what steps did you
>> take to try to overcome those limitations?


			     BOOT SECTOR
			     ===========

---- DATA STRUCTURES ----

>> B1: How did you decide to store the Disk Address Packet?  Does the
>> memory occupied by the DAP get reclaimed after it is used?  If not,
>> why not?

>> B2: How many sectors does your bootloader load?  How did you arrive
>> at this number?  Briefly explain your rationale.

>> B3: Does your bootloader pass any information to the main program?
>> (If not, just say no.)  If so, what information is passed, and how
>> is it passed?

---- ALGORITHMS ----

>> B3: Briefly describe how your bootloader brings your program into
>> memory.  Does it perform one large load, or multiple smaller loads?

>> B4: Did you add any BIOS calls to your bootloader to prepare for your
>> main program?  (i.e. things that aren't available in protected mode)

			  VIDEO SUBSYSTEM
			  ===============

---- DATA STRUCTURES ----

>> C1: What video display mode does your program use?  Is it a text mode
>> or a graphical mode?  Where does the video buffer start?  How is data
>> represented in this mode?  (Please be brief; we don't need complete
>> documentation on the video system.)

Our program uses text mode. The video buffer starts at 0xB8000. The display 
consists of text arranged into 25 80-char lines, and this text is stored in
the video buffer. Each character on the screen is represented by two bytes:
the first byte is the char, and the second byte is its color -- the lowest
four bits hold the foreground color and the highest three bits hold the 
background color. 

>> C2: Does your video code maintain any variables or data structures to
>> facilitate video output?  Briefly describe these values and their
>> purposes here.

Our video system stores data in 'grid,' a 2D array. Each element in the array
is two bytes, representing a character on screen in the convention described
in C1. The grid makes it easy to draw() shooters and bullets to (X, Y)
positions on the screen, or to set specific "pixels" on the screen. When 
display() is called, the data stored in 'grid' is transferred to the video
buffer.

We also store a default background color, since we don't anticipate that 
individual characters will typically different background colors.


---- ALGORITHMS ----

>> C3: What abstraction does your video code present to your main program?
>> Briefly describe the higher-level operations you decided to implement.

Our video API allows us to call functions like draw_shooter(), draw_bullet(),
clear_shooter(), and clear_bullet(). The higher-level draw() functions take
a Shooter or Bullet struct as a parameter. The structs specify the (X, Y) 
coordinates of the top left corner, as well as a 2x2 "image" of the 
Shooter/Bullet. The functions transform these attributes into the correct
data format to store in the grid. Similarly, the clear() functions remove the
Shooter/Bullet from the grid.

These higher-level operations allow us greater ease in drawing pictures 
composed of more than one character. Additionally, we implemented the 
set_pix() and set_grid_pix() functions to modify characters at specific (X, Y)
coordinates by transforming X and Y into an offset to add to the video buffer.



---- RATIONALE ----

>> C4: Did you take any specific steps to improve the appearance of your
>> program's display output?  For example, using Extended ASCII Codes, or
>> choosing specific colors to represent different things?


			  TIMER SUBSYSTEM
			  ===============

---- DATA STRUCTURES ----

>> D1: What state does your timer subsystem manage?  Describe the variables
>> or data structures that it maintains, and how they are used.

The timer subsystem stores a static int, timer_count, which is incremented
each time the a timer interrupt is fired. After each interrupt, timer_count
is passed to update_game(). Based on the value of timer_count, the aliens will
shoot bullets and the existing bullets will move. display() is also called to
refresh the video buffer with the updated positions.

---- ALGORITHMS ----

>> D2: What abstraction does your timer code present to your main program?
>> Briefly describe the higher-level operations you decided to implement.

>> D3: Did you change the timer frequency from 100Hz?  If so, what did you
>> change it to, and why?

---- SYNCHRONIZATION ----

>> D4: Given how your program handles timer events, is there any potential
>> for timer interrupts to generate race conditions in updating your
>> program's global state?  If so, what steps did you take to ensure that
>> such situations cannot occur?

			KEYBOARD SUBSYSTEM
			==================

---- DATA STRUCTURES ----

>> E1: What state does your keyboard subsystem manage?  Describe the variables
>> or data structures that it maintains, and how they are used.

>> E2: How do your data structures handle keys with multi-byte scan-codes?

---- ALGORITHMS ----

>> E3: What abstraction does your keyboard code present to your main program?
>> Briefly describe the higher-level operations you decided to implement.

>> E4: Does your keyboard subsystem expose scan-codes directly to your main
>> program, or does it preprocess them and expose other information to your
>> main program?  If scan-code data is preprocessed, briefly describe what
>> information is actually exposed, and how it is derived from scan-codes.

---- SYNCHRONIZATION ----

>> E5: Given how your keyboard interrupt handler operates, is there any
>> potential for race conditions in updating the keyboard subsystem's
>> internal state?  If so, what steps did you take to ensure that such
>> situations cannot occur?

>> E6: Given how your program handles keyboard events, is there any
>> potential for keyboard interrupts to generate race conditions in updating
>> your program's global state?  If so, what steps did you take to ensure
>> that such situations cannot occur?

---- RATIONALE ----

>> E7: Why did you choose the design and data representation that your
>> keyboard subsystem uses?  How is it suited to your program's overall
>> operation?

			  SURVEY QUESTIONS
			  ================

Answering these questions is optional, but it will help us improve the
course in future years.  Feel free to tell us anything you want - these
questions are just to spur your thoughts.  Also, feel free to be completely
honest if there are issues with the assignment or the course - you won't be
penalized.  We can't fix things until we know about them.  :-)

>> In your opinion, was this assignment, or any of the parts of it, too
>> easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Were there any parts of the assignment that you felt were unnecessarily
>> tedious or pointless?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the instructor and/or TAs to more
>> effectively assist students, either for future quarters or the remaining
>> projects?

>> Any other comments?

